'use strict';

process.env.PPTR_IMPL = process.env.PPTR_IMPL || 'rebrowser-puppeteer-core';

const readline = require('readline');
const util = require('util');
const fs = require('fs');
const path = require('path');

// Usar la librer√≠a local desde la ra√≠z
const { Client, auth: { LocalAuth } } = require('../index');

function rlInterface() {
  return readline.createInterface({ input: process.stdin, output: process.stdout });
}

function ask(rl, q) {
  return new Promise((resolve) => rl.question(q, (ans) => resolve(ans)));
}

function sleep(ms) { 
  return new Promise(r => setTimeout(r, ms)); 
}

function createClient() {
  return new Client({
    authStrategy: new LocalAuth({ clientId: 'v3-spec' }),
    puppeteer: { headless: false, channel: 'chrome' },
  });
}

function banner() {
  console.log('============================================');
  console.log('  WhatsApp Web - Funcionalities Mode');
  console.log('  Control manual de inicializaci√≥n');
  console.log('============================================');
}

function printMenu() {
  console.log('\nMen√∫:');
  console.log('1) Verificar estado del cliente');
  console.log('1.1) üîß Forzar carga de WWebJS y ClientInfo');
  console.log('1.2) üì° Activar/Desactivar eventos en tiempo real');
  console.log('2) Mostrar versi√≥n y estado');
  console.log('3) Listar chats');
  console.log('4) Obtener chat por ID');
  console.log('6) Obtener contacto por ID');
  console.log('0) Salir');
}

function pretty(obj) {
  try { 
    return JSON.stringify(obj, null, 2); 
  } catch { 
    return util.inspect(obj, { depth: 2, colors: true }); 
  }
}

// Verificar si el cliente est√° listo para operaciones
async function isClientReady(client) {
  try {
    if (!client || !client.pupPage) return false;
    
    const readyCheck = await client.pupPage.evaluate(() => {
      return {
        storeExists: typeof window.Store !== 'undefined',
        webJSExists: typeof window.WWebJS !== 'undefined',
        msgExists: typeof window.Store?.Msg !== 'undefined',
        chatExists: typeof window.Store?.Chat !== 'undefined',
        userExists: typeof window.Store?.User !== 'undefined'
      };
    });
    
    return readyCheck.storeExists && readyCheck.webJSExists && readyCheck.msgExists && readyCheck.chatExists;
  } catch (error) {
    return false;
  }
}

// Funci√≥n para forzar la inicializaci√≥n de client.info si no existe
async function ensureClientInfo(client) {
  try {
    if (!client.info && client.pupPage) {
      const { ClientInfo } = require('../src/structures');
      const infoData = await client.pupPage.evaluate(() => {
        if (window.Store && window.Store.Conn && window.Store.User) {
          return { 
            ...window.Store.Conn.serialize(), 
            wid: window.Store.User.getMeUser() 
          };
        }
        return null;
      });
      
      if (infoData) {
        client.info = new ClientInfo(client, infoData);
        console.log('‚úÖ Client info inicializado manualmente');
      }
    }
  } catch (error) {
    console.log('‚ö†Ô∏è No se pudo inicializar client.info:', error.message);
  }
}

// Variable para controlar los eventos personalizados
let customEventsAttached = false;
let eventListeners = [];

// Funci√≥n para registrar eventos personalizados (despu√©s de ready)
function attachCustomEventLoggers(client) {
  if (customEventsAttached) return;
  
  console.log('üì° Activando registro de eventos personalizados...');
  
  // Limpiar listeners previos
  removeCustomEventLoggers(client);
  
  // Crear listeners espec√≠ficos
  const listeners = [
    ['loading_screen', (percent, message) => console.log('üìÑ [loading_screen]', percent, message)],
    ['qr', (qr) => console.log('üì± [qr] QR code recibido')],
    ['code', (code) => console.log('üì¢ [code]', code)],
    ['authenticated', () => console.log('‚úÖ [authenticated] Usuario autenticado')],
    ['auth_failure', (msg) => console.log('‚ùå [auth_failure]', msg)],
    ['ready', () => console.log('üéâ [ready] Cliente listo')],
    
    // Mensajes
    ['message', (msg) => console.log('üì® [message]', { 
      id: msg.id?._serialized, 
      type: msg.type, 
      from: msg.from, 
      to: msg.to, 
      body: msg.body?.slice(0, 50) + '...' 
    })],
    ['message_create', (msg) => console.log('üìù [message_create]', { 
      id: msg.id?._serialized, 
      type: msg.type, 
      fromMe: msg.fromMe 
    })],
    ['message_ack', (msg, ack) => console.log('‚úÖ [message_ack]', { 
      id: msg.id?._serialized, 
      ack 
    })],
    ['message_revoke_me', (msg) => console.log('üóëÔ∏è [message_revoke_me]', { 
      id: msg.id?._serialized 
    })],
    ['message_revoke_everyone', (after, before) => console.log('üóëÔ∏è [message_revoke_everyone]', { 
      after: after?.id?._serialized, 
      before: before?.id?._serialized 
    })],
    ['message_ciphertext', (msg) => console.log('üîê [message_ciphertext]', { 
      id: msg.id?._serialized 
    })],
    ['message_edit', (msg, newBody, prevBody) => console.log('‚úèÔ∏è [message_edit]', { 
      id: msg.id?._serialized, 
      newBody: newBody?.slice(0, 30) + '...', 
      prevBody: prevBody?.slice(0, 30) + '...' 
    })],
    ['media_uploaded', (msg) => console.log('üìé [media_uploaded]', { 
      id: msg.id?._serialized 
    })],
    ['message_reaction', (reaction) => console.log('üëç [message_reaction]', reaction)],
    
    // Bater√≠a
    ['change_battery', ({ battery, plugged }) => console.log('üîã [battery_changed]', { battery, plugged })],
    
    // Grupos
    ['group_join', (notif) => console.log('üë• [group_join]', {
      chatId: notif.chatId,
      author: notif.author,
      participants: notif.participants
    })],
    ['group_leave', (notif) => console.log('üëã [group_leave]', {
      chatId: notif.chatId,
      author: notif.author,
      participants: notif.participants
    })],
    ['group_update', (notif) => console.log('üîÑ [group_update]', {
      chatId: notif.chatId,
      author: notif.author,
      type: notif.type
    })],
    ['group_admin_changed', (notif) => console.log('üëë [group_admin_changed]', {
      chatId: notif.chatId,
      author: notif.author,
      participants: notif.participants
    })],
    ['group_membership_request', (notif) => console.log('üìã [group_membership_request]', {
      chatId: notif.chatId,
      author: notif.author
    })],
    
    // Otros eventos
    ['chat_removed', (chat) => console.log('üóëÔ∏è [chat_removed]', { 
      id: chat?.id?._serialized 
    })],
    ['chat_archived', (chat, currState, prevState) => console.log('üì¶ [chat_archived]', { 
      id: chat?.id?._serialized, 
      currState, 
      prevState 
    })],
    ['unread_count', (chat) => console.log('üìä [unread_count]', { 
      id: chat?.id?._serialized, 
      unreadCount: chat?.unreadCount 
    })],
    ['change_state', (state) => console.log('üîÑ [change_state]', state)],
    ['contact_changed', (message, oldId, newId, isContact) => console.log('üë§ [contact_changed]', { 
      messageId: message?.id?._serialized, 
      oldId, 
      newId, 
      isContact 
    })],
    ['incoming_call', (call) => console.log('üìû [incoming_call]', {
      id: call.id,
      from: call.peerJid,
      isVideo: call.isVideo,
      isGroup: call.isGroup
    })],
    ['call', (call) => console.log('üìû [call]', call)],
    ['disconnected', (reason) => console.log('üîå [disconnected]', reason)]
  ];
  
  // Adjuntar listeners y guardar referencias
  listeners.forEach(([event, handler]) => {
    client.on(event, handler);
    eventListeners.push({ event, handler });
  });
  
  customEventsAttached = true;
  console.log('‚úÖ Eventos personalizados activados. Ver√°s todos los eventos en tiempo real.');
}

function removeCustomEventLoggers(client) {
  if (!customEventsAttached) return;
  
  console.log('üì° Desactivando registro de eventos personalizados...');
  
  // Remover solo los listeners espec√≠ficos que agregamos
  eventListeners.forEach(({ event, handler }) => {
    client.removeListener(event, handler);
  });
  
  eventListeners = [];
  customEventsAttached = false;
  console.log('‚úÖ Eventos personalizados desactivados.');
}

async function executeWithErrorHandling(client, operation, operationName) {
  if (!await isClientReady(client)) {
    console.log(`‚ùå Cliente no est√° listo para ${operationName}. Usa la opci√≥n 1 para verificar el estado.`);
    return null;
  }

  try {
    console.log(`üîÑ Ejecutando ${operationName}...`);
    return await operation();
  } catch (error) {
    console.error(`‚ùå Error en ${operationName}:`, error.message);
    return null;
  }
}

async function main() {
  banner();
  const rl = rlInterface();
  let client = null;

  try {
    console.log('üöÄ Creando cliente...');
    client = createClient();
    
    console.log('üåê Inicializando navegador...');
    await client.initialize();
    
    console.log('üì± Navegador lanzado. Autentica manualmente si es necesario...');
    await ask(rl, '\nüëÜ Cuando hayas autenticado y veas WhatsApp Web cargado, presiona Enter para continuar...');
    
    console.log('üîç Verificando que las dependencias de WhatsApp Web est√©n cargadas...');
    
    // Esperar a que window.Store est√© disponible
    await client.pupPage.waitForFunction('window.Store != undefined', { timeout: 20000 });
    console.log('‚úÖ window.Store detectado');
    
    // Esperar a que los m√≥dulos cr√≠ticos est√©n listos
    await client.pupPage.waitForFunction(
      'window.Store && window.Store.Msg && window.Store.Chat && window.Store.User', 
      { timeout: 30000 }
    );
    console.log('‚úÖ M√≥dulos cr√≠ticos de WhatsApp Web cargados');
    
    // Verificar y cargar WWebJS si no existe
    const webJSExists = await client.pupPage.evaluate(() => typeof window.WWebJS !== 'undefined');
    if (!webJSExists) {
      console.log('‚ö†Ô∏è window.WWebJS no encontrado, cargando Utils...');
      
      const { LoadUtils } = require('../src/Utils');
      await client.pupPage.evaluate(LoadUtils);
      
      const webJSLoaded = await client.pupPage.evaluate(() => typeof window.WWebJS !== 'undefined');
      if (webJSLoaded) {
        console.log('‚úÖ window.WWebJS cargado correctamente');
      } else {
        console.log('‚ùå Error cargando window.WWebJS');
      }
    } else {
      console.log('‚úÖ window.WWebJS ya existe');
    }
    
    // Esperar un poco m√°s para asegurar estabilidad
    await sleep(3000);
    
    // Forzar inicializaci√≥n de client.info autom√°ticamente
    console.log('üë§ Inicializando ClientInfo...');
    await ensureClientInfo(client);
    
    console.log('üéâ Cliente listo para usar!');

  } catch (error) {
    console.error('üí• Error durante la inicializaci√≥n:', error.message);
    console.log('üîß Intenta reiniciar la aplicaci√≥n o verificar tu conexi√≥n.');
    return;
  }

  let exit = false;
  while (!exit) {
    printMenu();
    const choice = await ask(rl, '\nüëâ Opci√≥n: ');
    
    try {
      switch ((choice || '').trim()) {
        case '1': {
          console.log('\n=== üîç DIAGN√ìSTICO DEL CLIENTE ===');
          console.log('Cliente existe:', !!client);
          console.log('pupPage existe:', !!client?.pupPage);
          console.log('pupBrowser existe:', !!client?.pupBrowser);
          console.log('client.info existe:', !!client?.info);
          
          if (client?.pupPage) {
            try {
              const state = await client.getState();
              console.log('Estado WhatsApp:', state);
              
              const version = await client.getWWebVersion();
              console.log('Versi√≥n WhatsApp Web:', version);
              
              const storeCheck = await client.pupPage.evaluate(() => ({
                storeExists: typeof window.Store !== 'undefined',
                webJSExists: typeof window.WWebJS !== 'undefined',
                msgExists: typeof window.Store?.Msg !== 'undefined',
                chatExists: typeof window.Store?.Chat !== 'undefined',
                userExists: typeof window.Store?.User !== 'undefined'
              }));
              
              console.log('Verificaci√≥n Store:', storeCheck);
              console.log('Cliente listo:', await isClientReady(client) ? '‚úÖ S√ç' : '‚ùå NO');
              
            } catch (error) {
              console.error('Error en diagn√≥stico:', error.message);
            }
          }
          console.log('=== üîç FIN DIAGN√ìSTICO ===\n');
          break;
        }

        case '1.1': {
          console.log('\nüîß FORZANDO CARGA DE DEPENDENCIAS...');
          try {
            console.log('üì¶ Cargando Utils...');
            const { LoadUtils } = require('../src/Utils');
            await client.pupPage.evaluate(LoadUtils);
            
            const webJSLoaded = await client.pupPage.evaluate(() => typeof window.WWebJS !== 'undefined');
            console.log('WWebJS cargado:', webJSLoaded ? '‚úÖ S√ç' : '‚ùå NO');
            
            console.log('üë§ Creando ClientInfo...');
            await ensureClientInfo(client);
            
            const finalCheck = await isClientReady(client);
            console.log('üéØ Cliente ahora est√° listo:', finalCheck ? '‚úÖ S√ç' : '‚ùå NO');
            
          } catch (error) {
            console.error('‚ùå Error en carga forzada:', error.message);
          }
          console.log('üîß FIN CARGA FORZADA\n');
          break;
        }

        case '1.2': {
          console.log('\nüì° GESTI√ìN DE EVENTOS EN TIEMPO REAL');
          console.log('Estado actual:', customEventsAttached ? '‚úÖ ACTIVADOS' : '‚ùå DESACTIVADOS');
          
          if (!customEventsAttached) {
            const confirm = await ask(rl, '¬øActivar eventos en tiempo real? (s/n): ');
            if (confirm.toLowerCase() === 's' || confirm.toLowerCase() === 'si') {
              // Verificar que el cliente est√© listo primero
              if (await isClientReady(client)) {
                attachCustomEventLoggers(client);
              } else {
                console.log('‚ùå Cliente no est√° listo. Usa la opci√≥n 1.1 para cargar dependencias.');
              }
            }
          } else {
            const confirm = await ask(rl, '¬øDesactivar eventos en tiempo real? (s/n): ');
            if (confirm.toLowerCase() === 's' || confirm.toLowerCase() === 'si') {
              removeCustomEventLoggers(client);
            }
          }
          break;
        }

        case '2': {
          try {
            const version = await client.getWWebVersion();
            const state = await client.getState();
            console.log('üåê WWeb Version:', version);
            console.log('üîó Estado:', state);
            console.log('‚ÑπÔ∏è Info cliente:', client.info ? '‚úÖ Disponible' : '‚ùå No disponible');
            if (client.info) {
              console.log('üë§ Usuario:', client.info.pushname || 'N/A');
              console.log('üì± Platform:', client.info.platform || 'N/A');
            }
            
            const webJSExists = await client.pupPage.evaluate(() => typeof window.WWebJS !== 'undefined');
            if (!webJSExists) {
              console.log('üîß Intentando cargar WWebJS...');
              const { LoadUtils } = require('../src/Utils');
              await client.pupPage.evaluate(LoadUtils);
              console.log('‚úÖ WWebJS cargado');
            }
            
          } catch (error) {
            console.error('‚ùå Error obteniendo informaci√≥n:', error.message);
          }
          break;
        }

        case '3': {
          await executeWithErrorHandling(client, async () => {
            const chats = await client.getChats();
            if (!chats || chats.length === 0) {
              console.log('üî≠ No se encontraron chats');
              return;
            }
            
            console.log('\nüìã LISTA DE CHATS:');
            chats.forEach((c, i) => {
              let name = 'Sin nombre';
              if (c.name) {
                name = c.name;
              } else if (c.formattedTitle) {
                name = c.formattedTitle;
              } else if (c.contact && c.contact.name) {
                name = c.contact.name;
              } else if (c.contact && c.contact.pushname) {
                name = c.contact.pushname;
              }
              
              const type = c.isGroup ? 'üë•' : 'üë§';
              const groupIcon = c.isGroup ? ' (Grupo)' : '';
              console.log(`${i + 1}. ${type} ${c.id._serialized} | ${name}${groupIcon}`);
            });
            console.log(`\nüìä Total: ${chats.length} chats`);
          }, 'listar chats');
          break;
        }

        case '4': {
          const id = await ask(rl, 'üÜî ID del chat: ');
          await executeWithErrorHandling(client, async () => {
            const chat = await client.getChatById(id.trim());
            console.log('üí¨ Chat encontrado:');
            console.log(pretty(chat));
          }, 'obtener chat por ID');
          break;
        }

        case '6': {
          const id = await ask(rl, 'üÜî ID del contacto: ');
          await executeWithErrorHandling(client, async () => {
            const contact = await client.getContactById(id.trim());
            console.log('üë§ Contacto encontrado:');
            console.log(pretty(contact));
          }, 'obtener contacto por ID');
          break;
        }

        case '0':
          console.log('üëã Saliendo...');
          exit = true;
          break;

        default:
          console.log('‚ùå Opci√≥n no v√°lida. Intenta de nuevo.');
      }
    } catch (err) {
      console.error('üí• Error inesperado:', err?.message || err);
      console.log('üîß Intenta usar la opci√≥n 1 para diagnosticar el problema.');
    }
  }

  console.log('üßπ Limpiando recursos...');
  
  // Limpiar eventos personalizados antes de cerrar
  if (customEventsAttached) {
    removeCustomEventLoggers(client);
  }
  
  rl.close();
  if (client?.pupBrowser) {
    try {
      await client.destroy();
    } catch (e) {
      console.log('‚ö†Ô∏è Error al cerrar cliente:', e.message);
    }
  }
  console.log('‚úÖ Aplicaci√≥n finalizada.');
}

main().catch((e) => {
  console.error('üí• Error fatal:', e);
  process.exit(1);
});